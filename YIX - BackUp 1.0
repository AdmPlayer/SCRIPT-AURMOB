setDefaultTab("main")

UI.Separator()
UI.Label("PARTY SCRIPTS:")
UI.Separator()

macro(1000,"AUTO ACCEPT PATY",function() 
  if player:getShield() > 2 then return end -- already in a party
  for s, spec in pairs(getSpectators(false)) do
    if spec:getShield() == 1 then
      g_game.partyJoin(spec:getId())
      delay(1000)
    end
  end
end)

UI.Separator()

local infoTime = 0
local talkTime = 0
local maxLevel = 0
local minLevel = 0
local justForInfo = true
local canSeeInfo = true
local partyMembersCount = 0
local lastTalkPrivateTime = 0

local partyLeaderHunt = macro(1000, "PARTY LEADER - NM", function()
  if not player:isPartyLeader() then
    justForInfo = true
    partyMembersCount = 0
    if player:isPartySharedExperienceActive() then 
      g_game.partyShareExperience(false) 
    end
    return
  end
  
  if not player:isPartySharedExperienceActive() then 
    g_game.partyShareExperience(true) 
  end
  
  if justForInfo and canSeeInfo then
    sayChannel(getChannelId("party"), "!party info")
    return
  end
  
  if talkTime > 0 then
    talkTime = talkTime - 1
  end
  
  if player:getShield() == 10 then
    infoTime = infoTime + 1
    if infoTime >= 20 then
      sayChannel(getChannelId("party"), "!party info")
      infoTime = 0
    end
  else
    infoTime = 0
  end
end)

-- Configuración de niveles
UI.Label("max level:")
UI.TextEdit(storage.maxLevel or "", function(widget, text)
  if tonumber(text) then
    maxLevel = tonumber(text)
  else
    sayChannel(getChannelId("party"), "!party info")
  end
  storage.maxLevel = tonumber(text)
end)

UI.Label("min level:")
UI.TextEdit(storage.minLevel or "", function(widget, text)
  if tonumber(text) then
    minLevel = tonumber(text)
  else
    sayChannel(getChannelId("party"), "!party info")
  end
  storage.minLevel = tonumber(text)
end)

onTalk(function(name, level, mode, text, channelId, pos)
  if partyLeaderHunt:isOn() then
    if name == player:getName() then return end
    if text:lower():find("pt") or (text:lower():find("party") and not text:lower():find("!party")) then
      for _, spec in ipairs(getSpectators()) do
        if spec:getName() == name then
          if spec:isPartyMember() then return end
          if spec:getShield() == 2 then
            if (os.time() - lastTalkPrivateTime) >= 5 then
              g_game.talkPrivate(5, name, name .. ", ACCEPT the PT and OPEN ROOM, please.")
              lastTalkPrivateTime = os.time()
            end
            return
          end
          if level > maxLevel or level < minLevel then
            if (os.time() - lastTalkPrivateTime) >= 5 then
              g_game.talkPrivate(5, name, name .. ", the minimum level is " .. minLevel .. " and the maximum is " .. maxLevel)
              lastTalkPrivateTime = os.time()
            end
            return
          end
          if partyMembersCount >= 30 then
            if (os.time() - lastTalkPrivateTime) >= 5 then
              g_game.talkPrivate(5, name, name .. ", PARTY is FULL, come back later.")
              lastTalkPrivateTime = os.time()
            end
            return
          end
          g_game.partyInvite(spec:getId())
        end
      end
    end
  end
end)

onLoginAdvice(function(text)
  if partyLeaderHunt:isOn() then
    local explode1 = string.explode(text, "*")
    local explode2 = string.explode(explode1[8], ":")[2]
    
    if not storage.maxLevel then
      maxLevel = math.ceil(tonumber(string.explode(explode1[4], ":")[2])*3/2)
    else
      maxLevel = storage.maxLevel
    end
    
    if not storage.minLevel then
      minLevel = math.ceil(tonumber(string.explode(explode1[3], ":")[2])*2/3)
    else
      minLevel = storage.minLevel
    end
    
    partyMembersCount = tonumber(string.explode(explode1[2], ":")[2])
    
    if justForInfo then
      justForInfo = false
      return
    end
    
    if explode2:find(",") then
      local names = string.explode(explode2, ",")
      for i = 1, #names do
        canSeeInfo = false
        schedule(1000 * i, function()
          if i == #names then
            canSeeInfo = true
          end
          sayChannel(getChannelId("party"), "!party kick," .. names[i])
        end)
      end
    elseif explode2 ~= "" then
      schedule(1000, function() 
        sayChannel(getChannelId("party"), "!party kick," .. explode2) 
      end)
    end
  end
end)

onCreatureAppear(function(creature)
  if partyLeaderHunt:isOn() then
    if not creature:isPlayer() then return end
    if creature:isLocalPlayer() then return end
    if creature:getShield() == 2 then return end
    if creature:isPartyMember() then return end
    if talkTime == 0 and partyMembersCount < 30 then
      say("If you want to join THE PARTY say PT and OPEN ROOM please")
      talkTime = 15
    end
  end
end)

onTextMessage(function(mode, text)
  if partyLeaderHunt:isOn() then
    if text:lower():find("you are now the leader of the party.") or 
       text:lower():find("has joined the party.") or 
       (text:lower():find("has left the party.") and canSeeInfo) then
      justForInfo = true
      if text:lower():find("you are now the leader of the party.") then
        g_game.partyShareExperience(true)
      end
    end
  end
end)

--

local lastShieldCheck = 0
local NO_SHARED_EXP_SHIELD = 7 -- Ajusta este valor según tu cliente

macro(100, "CHECK PARTY", function()
    -- Obtener el tiempo de espera configurado (convertir a milisegundos)
    local PARTY_EXIT_DELAY = (storage.partyExitDelay or 10) * 1000
    
    local localPlayer = g_game.getLocalPlayer()
    if not localPlayer then return end
    
    local shield = localPlayer:getShield()
    
    -- Si el escudo es de "No Shared Experience"
    if shield == NO_SHARED_EXP_SHIELD then
        if lastShieldCheck == 0 then
            lastShieldCheck = now
        elseif now - lastShieldCheck >= PARTY_EXIT_DELAY then
            say("!party exit")
            lastShieldCheck = 0
        end
    else
        lastShieldCheck = 0
    end
end)
UI.Label("secs to exit (no shared)")
UI.TextEdit(tostring(storage.partyExitDelay or "10"), function(widget, text)
    storage.partyExitDelay = tonumber(text) or 10
end)

setDefaultTab("hp")
local hpPercent = 95
local xura = macro(100, "HEAL SPELL - 95%", function()
    if hppercent() <= hpPercent then
        say(storage.HealText or "exura vita")
    end
end)

addTextEdit("HealText", storage.HealText or "exura vita", function(widget, text)
    storage.HealText = text
end)

mpPot = macro(200, "MANA POT - MAGE", function() 
  if (manapercent() < (storage.potManaPercent or 90)) then 
    usewith(23373, player) 
  end 
end)
UI.Label("mana % percent")
UI.TextEdit(tostring(storage.potManaPercent or "90"), function(widget, text)
  storage.potManaPercent = tonumber(text) or 90
end)


UI.Separator()
UI.Label("HP - II")
UI.Separator()

Panels.Health()
UI.Separator()
Panels.HealthItem()
Panels.ManaItem()
 
setDefaultTab("Inmortal")
UI.Separator()

local amulet = 3081
local SsaFull = macro(170, function()
    if getNeck() == nil or getNeck():getId() ~= amulet then
        g_game.equipItemId(amulet)
        delay(30)
    end
end)

local SsaFull = addIcon("SsaFul", {item = 3081, text = "SSA"}, function(icon, isOn)
    SsaFull.setOn(isOn)
end)

-- Improved drag system with F2
local function activeDrag(icon, nameMacro, position)
    SsaFull:breakAnchors()
    SsaFull:move(position.posX or 750, position.posY or 20)  -- Default position (750, 20)

    SsaFull.onDragEnter = function(widget, mousePos)
        if not g_keyboard.isKeyPressed("F2") then
            return false
        end
        SsaFull:breakAnchors()
        SsaFull.movingReference = { x = mousePos.x - SsaFull:getX(), y = mousePos.y - SsaFull:getY() }
        return true
    end

    SsaFull.onDragMove = function(widget, mousePos, moved)
        if not g_keyboard.isKeyPressed("F2") then
            return false
        end
        local parentRect = widget:getParent():getRect()
        local x = math.min(math.max(parentRect.x, mousePos.x - widget.movingReference.x), parentRect.x + parentRect.width - widget:getWidth())
        local y = math.min(math.max(parentRect.y - widget:getParent():getMarginTop(), mousePos.y - widget.movingReference.y), parentRect.y + parentRect.height - widget:getHeight())
        widget:move(x, y)
        return true
    end

    SsaFull.onDragLeave = function(widget, pos)
        storage[nameMacro] = { posX = SsaFull:getX(), posY = SsaFull:getY() }
    end
end

activeDrag(SsaFull, 'SsaFul', storage.SsaFul or {})

--

local might = 3048
local MightFull = macro(170, function()
    if getFinger() == nil or getFinger():getId() ~= might then
        g_game.equipItemId(might)
        delay(30)
    end
end)

local MightFull = addIcon("MightFul", {item = 3048, text = "MIGHT"}, function(icon, isOn)
    MightFull.setOn(isOn)
end)

-- Improved drag system with F2
local function activeDrag(icon, nameMacro, position)
    MightFull:breakAnchors()
    MightFull:move(position.posX or 700, position.posY or 20)  -- Default position (700, 20)

    MightFull.onDragEnter = function(widget, mousePos)
        if not g_keyboard.isKeyPressed("F2") then
            return false
        end
        MightFull:breakAnchors()
        MightFull.movingReference = { x = mousePos.x - MightFull:getX(), y = mousePos.y - MightFull:getY() }
        return true
    end

    MightFull.onDragMove = function(widget, mousePos, moved)
        if not g_keyboard.isKeyPressed("F2") then
            return false
        end
        local parentRect = widget:getParent():getRect()
        local x = math.min(math.max(parentRect.x, mousePos.x - widget.movingReference.x), parentRect.x + parentRect.width - widget:getWidth())
        local y = math.min(math.max(parentRect.y - widget:getParent():getMarginTop(), mousePos.y - widget.movingReference.y), parentRect.y + parentRect.height - widget:getHeight())
        widget:move(x, y)
        return true
    end

    MightFull.onDragLeave = function(widget, pos)
        storage[nameMacro] = { posX = MightFull:getX(), posY = MightFull:getY() }
    end
end

activeDrag(MightFull, 'MightFul', storage.MightFul or {})

--

-- Energy Ring Configuration
local item = {eq = 3088, bp = 3051} -- ID del anillo equipado y en la mochila
local hp = {min = 80, max = 99}     -- Porcentajes iniciales
local slot = SlotFinger
local oldVersions = false           -- true para servidores sin equipar por hotkey

-- Core Macro
eRing = macro(500, function()
    local life = hppercent()
    if life <= hp.min then
        equipItem(getSlot(slot))  -- Equipar si HP ≤ min
    elseif life >= hp.max then
        removeItem(getSlot(slot)) -- Quitar si HP ≥ max
    end
end)

-- Equipment Functions
function equipItem(equipped)
    if not equipped or equipped:getId() ~= item.eq then
        if oldVersions then
            local ring = findItem(item.bp)
            if ring then moveToSlot(ring, slot) end
        else
            g_game.equipItemId(item.bp)
        end
    end
end

function removeItem(equipped)
    if equipped and equipped:getId() == item.eq then
        if oldVersions then
            moveToSlot(equipped, SlotBack)
        else
            g_game.equipItemId(item.eq)
        end
    end
end

-- Icon Setup
eRing = addIcon("energyR", {item = 3051, text = "E-RING"}, function(icon, isOn)
    eRing.setOn(isOn)
end)

-- F2 Drag System
local function activeDrag(icon, nameMacro, position)
    eRing:breakAnchors()
    eRing:move(position.posX or 200, position.posY or 30)  -- Default position (200, 30)

    eRing.onDragEnter = function(widget, mousePos)
        if not g_keyboard.isKeyPressed("F2") then
            return false
        end
        eRing:breakAnchors()
        eRing.movingReference = { x = mousePos.x - eRing:getX(), y = mousePos.y - eRing:getY() }
        return true
    end

    eRing.onDragMove = function(widget, mousePos, moved)
        if not g_keyboard.isKeyPressed("F2") then
            return false
        end
        local parentRect = widget:getParent():getRect()
        local x = math.min(math.max(parentRect.x, mousePos.x - widget.movingReference.x), parentRect.x + parentRect.width - widget:getWidth())
        local y = math.min(math.max(parentRect.y - widget:getParent():getMarginTop(), mousePos.y - widget.movingReference.y), parentRect.y + parentRect.height - widget:getHeight())
        widget:move(x, y)
        return true
    end

    eRing.onDragLeave = function(widget, pos)
        storage[nameMacro] = { posX = eRing:getX(), posY = eRing:getY() }
    end
end

activeDrag(eRing, 'energyR', storage.energyR or {})

--

function theinmortal()
    local panelName = "theinmortal"
    local UI = setupUI([[
Panel
  height: 190
  margin-top: 2

  Label
    id: label1
    text:I N M O R T A L
    anchors.top: parent.top
    anchors.left: parent.left
    margin-left: 50
    color: white
    text-align: center

  Label
    id: labelSSA
    text: SSA when <= 50%:
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: label1.bottom
    margin-top: 5
    margin-left: 1
    color: #77D390
    text-align: center

  HorizontalScrollBar
    id: scrollSSA
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: labelSSA.bottom
    margin-left: 5
    margin-right: 5
    margin-top: 5
    minimum: 1
    maximum: 100
    step: 1

  Label
    id: labelMR
    text: MIGHT RING when <= 50%:
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: scrollSSA.bottom
    color: #77D390
    margin-top: 5
    text-align: center

  HorizontalScrollBar
    id: scrollMR
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: labelMR.bottom
    margin-left: 5
    margin-right: 5
    margin-top: 5
    minimum: 1
    maximum: 100
    step: 1

  Label
    id: labelUtamo
    text: Utamo Ring when <= 50%:
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: scrollMR.bottom
    color: #77D390
    margin-top: 5
    text-align: center

  HorizontalScrollBar
    id: scrollUtamo
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: labelUtamo.bottom
    margin-left: 5
    margin-right: 5
    margin-top: 5
    minimum: 1
    maximum: 100
    step: 1

  BotSwitch
    id: switch
    anchors.top: scrollUtamo.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: 15 
    text-align: center
    width: 130
    height: 25
    !text: tr('INMORTAL')

  BotSwitch
    id: switchUtamo
    anchors.top: switch.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: 10
    text-align: center
    text: Anillo Utamo
    height: 20
    color: #599dff
]])
    if not storage[panelName] then
        storage[panelName] = {
            ssaValue = 70,
            mrValue = 70,
            uRingValue = 30,
            btnInmortal = false,
            btnAnilloU = false
        }
    end

    UI.switch:setOn(storage[panelName].btnInmortal)
    UI.switch.onClick = function(widget)
        storage[panelName].btnInmortal = not storage[panelName].btnInmortal
        widget:setOn(storage[panelName].btnInmortal)
    end

    UI.switchUtamo:setOn(storage[panelName].btnAnilloU)
    UI.switchUtamo.onClick = function(widget)
        storage[panelName].btnAnilloU = not storage[panelName].btnAnilloU
        widget:setOn(storage[panelName].btnAnilloU)
    end

    UI.labelSSA:setText("SSA ON <= " .. storage[panelName].ssaValue .. "%")

    UI.scrollSSA:setValue(storage[panelName].ssaValue)
    UI.scrollSSA.onValueChange = function(scroll, value)
        storage[panelName].ssaValue = value
        UI.labelSSA:setText("SSA ON <= " .. value .. "%")
    end

    UI.labelMR:setText("MIGHT RING ON <= " .. storage[panelName].mrValue .. "%")
    UI.scrollMR:setValue(storage[panelName].mrValue)
    UI.scrollMR.onValueChange = function(scroll, value)
        storage[panelName].mrValue = value
        UI.labelMR:setText("MIGHT RING ON <= " .. value .. "%")
    end

    UI.labelUtamo:setText("UTAMO RING ON <= " .. storage[panelName].uRingValue .. "%")
    UI.scrollUtamo:setValue(storage[panelName].uRingValue)
    UI.scrollUtamo.onValueChange = function(scroll, value)
        storage[panelName].uRingValue = value
        UI.labelUtamo:setText("UTAMO RING ON <= " .. value .. "%")
    end

    local amulet = 3081
    local ring = 3048
    local ering = 3051
    local aering = 3088
    local lastAction = now

    function desequipar(value)
        local item = Item.create(value)
        g_game.equipItem(item)
    end

    -- basic ring check
    function defaultRingFind()
        if storage[panelName].ringEnabled then
            if getFinger() and (getFinger():getId() ~= ring and getFinger():getId() ~= getActiveItemId(ring)) then
                defaultRing = getInactiveItemId(getFinger():getId())
            else
                defaultRing = false
            end
        end
    end

    -- basic amulet check
    function defaultAmmyFind()
        if storage[panelName].ammyEnabled then
            if getNeck() and (getNeck():getId() ~= amulet and getNeck():getId() ~= getActiveItemId(amulet)) then
                defaultAmmy = getInactiveItemId(getNeck():getId())
            else
                defaultAmmy = false
            end
        end
    end

    macro(10, function()
        if now - lastAction < math.max(math.max(g_game.getPing() * 2, 150), 300) then
            return
        end
        if not storage[panelName].btnInmortal then
            return
        end

        local eringEquipped = getFinger() and (getFinger():getId() == aering)
        local ringEquipped = getFinger() and
                                 (getFinger():getId() == ring or getFinger():getId() == getActiveItemId(ring))
        local ssaEquipped = getNeck() and (getNeck():getId() == amulet or getNeck():getId() == getActiveItemId(amulet))

        if eringEquipped then
            -- SSA --
            if not ssaEquipped and storage[panelName].btnAnilloU then
                defaultAmmyFind()
                if hppercent() <= storage[panelName].ssaValue then
                    g_game.equipItemId(amulet)
                    lastAction = now
                    return
                end
            elseif ssaEquipped and hppercent() > storage[panelName].ssaValue then
                desequipar(amulet)
                lastAction = now
                return
            end
        end

        -- SI NO TIENE ACTIVADO EL BOTON DE E RING
        if not storage[panelName].btnAnilloU then
            if hasManaShield() then
                -- MIGHT RING --
                if not ringEquipped then
                    defaultRingFind()
                    if manapercent() <= storage[panelName].mrValue then
                        g_game.equipItemId(ring)
                        lastAction = now
                        return
                    end
                elseif ringEquipped then
                    if manapercent() > storage[panelName].mrValue then
                        desequipar(ring)
                        lastAction = now
                        return
                    end
                end

            elseif not hasManaShield() then
                -- MIGHT RING --
                if not ringEquipped then
                    defaultRingFind()
                    if hppercent() <= storage[panelName].mrValue then
                        g_game.equipItemId(ring)
                        lastAction = now
                        return
                    end
                elseif ringEquipped then
                    if hppercent() > storage[panelName].mrValue then
                        desequipar(ring)
                        lastAction = now
                        return
                    end
                end
            end

        end
        if storage[panelName].btnAnilloU then
            -- MIGHT RING --
            if not ringEquipped then
                defaultRingFind()
                if hppercent() <= storage[panelName].mrValue and hppercent() > storage[panelName].uRingValue then
                    g_game.equipItemId(ring)
                    lastAction = now
                    return
                elseif hppercent() <= storage[panelName].uRingValue or
                    (getFinger() == nil and hppercent() <= storage[panelName].uRingValue) then
                    g_game.equipItemId(ering)
                    lastAction = now
                    return
                elseif eringEquipped and hppercent() > storage[panelName].uRingValue then
                    desequipar(aering)
                    lastAction = now
                    return
                end
            elseif ringEquipped then
                if hppercent() > storage[panelName].mrValue then
                    desequipar(ring)
                    lastAction = now
                    return
                end
                if hppercent() <= storage[panelName].uRingValue then
                    g_game.equipItemId(ering)
                    lastAction = now
                    return
                end
            end
        end

        if storage[panelName].btnAnilloU and storage[panelName].mrValue <= storage[panelName].uRingValue then
            warn("NO PUEDES PONER MAS ALTO EL PORCENTAJE DEL ENERGY RING QUE EL DE MIGHT RING")
            storage[panelName].uRingValue = storage[panelName].mrValue - 10
            UI.scrollUtamo:setValue(storage[panelName].uRingValue)
            UI.labelUtamo:setText("UTAMO RING ON <= " .. storage[panelName].uRingValue .. "%")
            return
        end
        if hasManaShield() then
            -- SSA --
            if not ssaEquipped then
                defaultAmmyFind()
                if manapercent() <= storage[panelName].ssaValue then
                    g_game.equipItemId(amulet)
                    lastAction = now
                    return
                end
            elseif ssaEquipped and manapercent() > storage[panelName].ssaValue then
                desequipar(amulet)
                lastAction = now
                return
            end
        else
            -- SSA --
            if not ssaEquipped then
                defaultAmmyFind()
                if hppercent() <= storage[panelName].ssaValue then
                    g_game.equipItemId(amulet)
                    lastAction = now
                    return
                end
            elseif ssaEquipped and hppercent() > storage[panelName].ssaValue then
                desequipar(amulet)
                lastAction = now
                return
            end
        end

        
    end)
end -- END FUNCTION theinmortal

if g_game.getClientVersion() >= 1000 then
    theinmortal()
    
end
UI.Separator()
UI.Label("No puedes colocar ANILLO UTAMO por encima de SSA y MIGHT.")
--

-- ===== ICONOS ===== --

-- CaveBot Icon
local cIcon = addIcon("cI", {text = "Cave Bot", switchable = false, moveable = true}, function()
    if CaveBot.isOff() then 
        CaveBot.setOn()
    else 
        CaveBot.setOff()
    end
end)
cIcon:setSize({height = 30, width = 50})
cIcon.text:setFont('verdana-11px-rounded')

-- TargetBot Icon
local tIcon = addIcon("tI", {text = "Target Bot", switchable = false, moveable = true}, function()
    if TargetBot.isOff() then 
        TargetBot.setOn()
    else 
        TargetBot.setOff()
    end
end)
tIcon:setSize({height = 30, width = 50})
tIcon.text:setFont('verdana-11px-rounded')

-- AttackBot Icon
local aIcon = addIcon("aI", {text = "Attack Bot", switchable = false, moveable = true}, function()
    if AttackBot.isOff() then 
        AttackBot.setOn()
    else 
        AttackBot.setOff()
    end
end)
aIcon:setSize({height = 30, width = 50})
aIcon.text:setFont('verdana-11px-rounded')

-- Status Updater
macro(50, function()
    -- CaveBot Status
    if CaveBot.isOn() then
        cIcon.text:setColoredText({"CAVE Bot", "green","\nON","red"})
    else
        cIcon.text:setColoredText({"CAVE Bot", "white","\nOFF","red" })
    end
    
    -- TargetBot Status
    if TargetBot.isOn() then
        tIcon.text:setColoredText({"TARGET Bot", "white", "\nON", "green"})
    else
        tIcon.text:setColoredText({"TARGET Bot", "white", "\nOFF", "red"})
    end
    
    -- AttackBot Status
    if AttackBot.isOn() then
        aIcon.text:setColoredText({"ATTACK <[^.^]>\n-ON-", "green"})
    else
        aIcon.text:setColoredText({"ATTACK <[o.o]>\nBOT", "white"})
    end
end)

-- Improved F2 Drag System for all icons
local function setupDrag(icon, storageKey, defaultX, defaultY)
    icon:breakAnchors()
    icon:move(storage[storageKey] and storage[storageKey].posX or defaultX, 
              storage[storageKey] and storage[storageKey].posY or defaultY)

    icon.onDragEnter = function(widget, mousePos)
        if not g_keyboard.isKeyPressed("F2") then return false end
        icon:breakAnchors()
        icon.movingReference = {x = mousePos.x - icon:getX(), y = mousePos.y - icon:getY()}
        return true
    end

    icon.onDragMove = function(widget, mousePos, moved)
        if not g_keyboard.isKeyPressed("F2") then return false end
        local parentRect = widget:getParent():getRect()
        local x = math.max(parentRect.x, math.min(mousePos.x - icon.movingReference.x, parentRect.x + parentRect.width - widget:getWidth()))
        local y = math.max(parentRect.y, math.min(mousePos.y - icon.movingReference.y, parentRect.y + parentRect.height - widget:getHeight()))
        widget:move(x, y)
        return true
    end

    icon.onDragLeave = function(widget, pos)
        storage[storageKey] = {posX = icon:getX(), posY = icon:getY()}
    end
end

-- Set up drag for each icon with default positions
setupDrag(cIcon, 'caveBotIcon', 50, 50)    -- Default position (50, 50)
setupDrag(tIcon, 'targetBotIcon', 110, 50) -- Default position (110, 50)
setupDrag(aIcon, 'attackBotIcon', 170, 50) -- Default position (170, 50)

--

flwT = addIcon("flwT", {item = 16201, text = "FOLLOW"}, 
macro(200, function()
    if g_game.isOnline() and g_game.isAttacking() then
        g_game.setChaseMode(1)
    end
end))

local function activeDrag(icon, nameMacro, position)
    flwT:breakAnchors()
    flwT:move(position.posX or 10, position.posY or 90)

    flwT.onDragEnter = function(widget, mousePos)
        if not g_keyboard.isKeyPressed("F2") then
            return false
        end
        flwT:breakAnchors()
        flwT.movingReference = { x = mousePos.x - flwT:getX(), y = mousePos.y - flwT:getY() }
        return true
    end

    flwT.onDragMove = function(widget, mousePos, moved)
        if not g_keyboard.isKeyPressed("F2") then
            return false
        end
        local parentRect = widget:getParent():getRect()
        local x = math.min(math.max(parentRect.x, mousePos.x - widget.movingReference.x), parentRect.x + parentRect.width - widget:getWidth())
        local y = math.min(math.max(parentRect.y - widget:getParent():getMarginTop(), mousePos.y - widget.movingReference.y), parentRect.y + parentRect.height - widget:getHeight())
        widget:move(x, y)
        return true
    end

    flwT.onDragLeave = function(widget, pos)
        storage[nameMacro] = { posX = flwT:getX(), posY = flwT:getY() }
    end
end

activeDrag(flwT, 'flwT', storage.flwT or {})

--

local oldTarget = macro(505, "", nil, function()
    if g_game.isAttacking() then
        oldTarget = g_game.getAttackingCreature()
    end
    if (oldTarget and oldTarget:getPosition()) then
        if (not g_game.isAttacking() and getDistanceBetween(pos(), oldTarget:getPosition()) <= 8) then
            if (oldTarget:getPosition().z == posz()) then
                g_game.attack(oldTarget)
            end
        end
    end
end)

oldTarget = addIcon("oldTarget", {item = 2025, text = "HOLD"}, oldTarget)

local function activeDrag(icon, nameMacro, position)
    oldTarget:breakAnchors()
    oldTarget:move(position.posX or 70, position.posY or 90)

    oldTarget.onDragEnter = function(widget, mousePos)
        if not g_keyboard.isKeyPressed("F2") then
            return false
        end
        oldTarget:breakAnchors()
        oldTarget.movingReference = { x = mousePos.x - oldTarget:getX(), y = mousePos.y - oldTarget:getY() }
        return true
    end

    oldTarget.onDragMove = function(widget, mousePos, moved)
        if not g_keyboard.isKeyPressed("F2") then
            return false
        end
        local parentRect = widget:getParent():getRect()
        local x = math.min(math.max(parentRect.x, mousePos.x - widget.movingReference.x), parentRect.x + parentRect.width - widget:getWidth())
        local y = math.min(math.max(parentRect.y - widget:getParent():getMarginTop(), mousePos.y - widget.movingReference.y), parentRect.y + parentRect.height - widget:getHeight())
        widget:move(x, y)
        return true
    end

    oldTarget.onDragLeave = function(widget, pos)
        storage[nameMacro] = { posX = oldTarget:getX(), posY = oldTarget:getY() }
    end
end

activeDrag(oldTarget, 'oldTarget', storage.oldTarget or {})

--

function distanceFromPlayer(position)
    local playerPosition = g_game.getLocalPlayer():getPosition()
    return math.max(math.abs(playerPosition.x - position.x), math.abs(playerPosition.y - position.y))
end
--[Use All]
--Modded from vBot 4.8
storage.shovel = 3457
storage.rope = 3003
storage.machete = 3308
storage.scythe = 3453

local useId = { 34847, 1764, 21051, 30823, 6264, 5282, 20453, 20454, 20474, 11708, 11705, 
                6257, 6256, 2772, 27260, 2773, 1632, 1633, 1948, 435, 6252, 6253, 5007, 4911, 
                1629, 1630, 5108, 5107, 5281, 1968, 435, 1948, 5542, 31116, 31120, 30742, 31115, 
                31118, 20474, 5737, 5736, 5734, 5733, 31202, 31228, 31199, 31200, 33262, 30824, 
                5125, 5126, 5116, 5117, 8257, 8258, 8255, 8256, 5120, 30777, 30776, 23873, 23877,
                5736, 6264, 31262, 31130, 31129, 6250, 6249, 5122, 30049, 7131, 7132, 7727 }
local shovelId = { 606, 593, 867, 608 }
local ropeId = { 17238, 12202, 12935, 386, 421, 21966, 14238 }
local macheteId = { 2130, 3696 }
local scytheId = { 3653 }

useAll = macro(310, function(self)
    for _, tile in pairs(g_map.getTiles(posz())) do
        if distanceFromPlayer(tile:getPosition()) < 2 then
            for _, item in pairs(tile:getItems()) do
                -- use
                if table.find(useId, item:getId()) then
                    use(item)
                    useAll.setOff()
                    return
                elseif table.find(shovelId, item:getId()) then
                    useWith(storage.shovel, item)
                    useAll.setOff()
                    return
                elseif table.find(ropeId, item:getId()) then
                    useWith(storage.rope, item) 
                    useAll.setOff()
                    return
                elseif table.find(macheteId, item:getId()) then
                    useWith(storage.machete, item)
                    useAll.setOff()
                    return
                elseif table.find(scytheId, item:getId()) then
                    useWith(storage.scythe, item)
                    useAll.setOff()
                    return
                end
            end
        end
    end
    self.setOn(false)
end)

useAllPro = addIcon("useall", {item = 9599, text = "USE ALL", switchable = false}, function()
    if useAll.isOn() then
        useAll.setOff()
    else
        useAll.setOn()
    end
end)

local function activeDrag(icon, nameMacro, position)
    useAllPro:breakAnchors()
    useAllPro:move(position.posX or 240, position.posY or 440)

    useAllPro.onDragEnter = function(widget, mousePos)
        if not g_keyboard.isKeyPressed("F2") then -- Changed from F1 to F2
            return false
        end
        useAllPro:breakAnchors()
        useAllPro.movingReference = { x = mousePos.x - useAllPro:getX(), y = mousePos.y - useAllPro:getY() }
        return true
    end

    useAllPro.onDragMove = function(widget, mousePos, moved)
        if not g_keyboard.isKeyPressed("F2") then -- Changed from F1 to F2
            return false
        end
        local parentRect = widget:getParent():getRect()
        local x = math.min(math.max(parentRect.x, mousePos.x - widget.movingReference.x), parentRect.x + parentRect.width - widget:getWidth())
        local y = math.min(math.max(parentRect.y - widget:getParent():getMarginTop(), mousePos.y - widget.movingReference.y), parentRect.y + parentRect.height - widget:getHeight())
        widget:move(x, y)
        useAllPro.moving = { x = useAllPro:getX(), y = useAllPro:getY() }
        return true
    end

    useAllPro.onDragLeave = function(widget, pos)
        storage[nameMacro] = { posX = useAllPro:getX(), posY = useAllPro:getY() }
    end
end

activeDrag(useAllPro, 'useall', storage.useall or {})

--

local bugMapMobile = {};

local cursorWidget = g_ui.getRootWidget():recursiveGetChildById('pointer');

local initialPos = { x = cursorWidget:getPosition().x / cursorWidget:getWidth(), y = cursorWidget:getPosition().y / cursorWidget:getHeight() };

local availableKeys = {
    ['Up'] = { 0, -6 },
    ['Down'] = { 0, 6 },
    ['Left'] = { -7, 0 },
    ['Right'] = { 7, 0 }
};

function bugMapMobile.logic()
    local pos = pos();
    local keypadPos = { x = cursorWidget:getPosition().x / cursorWidget:getWidth(), y = cursorWidget:getPosition().y / cursorWidget:getHeight() };
    local diffPos = { x = initialPos.x - keypadPos.x, y = initialPos.y - keypadPos.y };

    if (diffPos.y < 0.46 and diffPos.y > -0.46) then
        if (diffPos.x > 0) then
            pos.x = pos.x + availableKeys['Left'][1];
        elseif (diffPos.x < 0) then
            pos.x = pos.x + availableKeys['Right'][1];
        else return end
    elseif (diffPos.x < 0.46 and diffPos.x > -0.46) then
        if (diffPos.y > 0) then
            pos.y = pos.y + availableKeys['Up'][2];
        elseif (diffPos.y < 0) then
            pos.y = pos.y + availableKeys['Down'][2];
        else return; end
    end
    local tile = g_map.getTile(pos);
    if (not tile) then return; end

    g_game.use(tile:getTopUseThing());
end

iconBugMap = macro(18, "", bugMapMobile.logic);
positions = addIcon("bMp", {item = 10200, text= "BugMAP"}, iconBugMap)

local function activeDrag(icon, nameMacro, position)
    positions:breakAnchors()
    positions:move(position.posX or 500, position.posY or 440)

    positions.onDragEnter = function(widget, mousePos)
        if not g_keyboard.isKeyPressed("F2") then -- Cambiado de F1 a F2
            return false
        end
        positions:breakAnchors()
        positions.movingReference = { 
            x = mousePos.x - positions:getX(), 
            y = mousePos.y - positions:getY() 
        }
        return true
    end

    positions.onDragMove = function(widget, mousePos, moved)
        if not g_keyboard.isKeyPressed("F2") then -- Cambiado de F1 a F2
            return false
        end
        local parentRect = widget:getParent():getRect()
        local x = math.min(math.max(parentRect.x, mousePos.x - widget.movingReference.x), parentRect.x + parentRect.width - widget:getWidth())
        local y = math.min(math.max(parentRect.y - widget:getParent():getMarginTop(), mousePos.y - widget.movingReference.y), parentRect.y + parentRect.height - widget:getHeight())
        widget:move(x, y)
        return true
    end

    positions.onDragLeave = function(widget, pos)
        storage[nameMacro] = { 
            posX = positions:getX(), 
            posY = positions:getY() 
        }
    end
end

activeDrag(positions, 'bMp', storage.bMp or {})

--

local minimapWindow = modules.game_minimap.minimapWindow
local rootWidget = g_ui.getRootWidget()
local lastPos = {x = 150, y = 100}
local tam = math.floor(rootWidget:getRect().height/1.8)

-- Create the minimap toggle icon
local miniMapIcon = addIcon("toggleMiniMap", {item=43739, text="MAP"}, function(icon, isOn)
    if isOn then
        minimapWindow:setParent(modules.game_interface.getRootPanel())
        minimapWindow:show()
        minimapWindow:move(lastPos.x, lastPos.y)
        minimapWindow:resize(tam, tam)
    else
        minimapWindow:setParent(modules.game_interface.getRightPanel())
        minimapWindow:hide()
        minimapWindow:resize(192, 150)
        minimapWindow:setMarginLeft(0)
    end
end)

-- Save minimap position when dragged
local copyOnDrag = minimapWindow.onDragLeave
minimapWindow.onDragLeave = function(widget, droppedWidget, mousePos)
    copyOnDrag(widget, droppedWidget, mousePos)
    lastPos = {x = minimapWindow:getX(), y = minimapWindow:getY()}
end

-- Resize minimap when window changes
rootWidget.onGeometryChange[7] = function(widget)
    if minimapWindow:isHidden() then return end
    tam = math.floor(rootWidget:getRect().height/1.8)
    minimapWindow:resize(tam, tam)
end

-- Modified drag function for the icon (F2 only)
local function activeDrag(icon, nameMacro, position)
    icon:breakAnchors()
    icon:move(position.posX or 60, position.posY or 350)

    icon.onDragEnter = function(widget, mousePos)
        if not g_keyboard.isKeyPressed("F2") then  -- Changed to F2
            return false
        end
        icon:breakAnchors()
        icon.movingReference = { x = mousePos.x - icon:getX(), y = mousePos.y - icon:getY() }
        return true
    end

    icon.onDragMove = function(widget, mousePos, moved)
        if not g_keyboard.isKeyPressed("F2") then  -- Changed to F2
            return false
        end
        local parentRect = widget:getParent():getRect()
        local x = math.min(math.max(parentRect.x, mousePos.x - widget.movingReference.x), parentRect.x + parentRect.width - widget:getWidth())
        local y = math.min(math.max(parentRect.y - widget:getParent():getMarginTop(), mousePos.y - widget.movingReference.y), parentRect.y + parentRect.height - widget:getHeight())
        widget:move(x, y)
        icon.moving = { x = icon:getX(), y = icon:getY() }
        return true
    end

    icon.onDragLeave = function(widget, pos)
        storage[nameMacro] = { posX = icon:getX(), posY = icon:getY() }
    end
end

activeDrag(miniMapIcon, 'toggleMiniMap', storage.toggleMiniMap or {})

--

local cancelAtaq = addIcon("stopAttack", {item = 34023, text = "NO ATK", switchable = false}, function(widget, isOn)
    g_game.cancelAttackAndFollow()
    g_game.cancelAttackAndFollow()
    g_game.cancelAttackAndFollow()
end)

local function activeDrag(icon, nameMacro, position)
    cancelAtaq:breakAnchors()
    cancelAtaq:move(position.posX or 60, position.posY or 350)

    cancelAtaq.onDragEnter = function(widget, mousePos)
        if not g_keyboard.isKeyPressed("F2") then -- Changed from F1 to F2
            return false
        end
        cancelAtaq:breakAnchors()
        cancelAtaq.movingReference = { x = mousePos.x - cancelAtaq:getX(), y = mousePos.y - cancelAtaq:getY() }
        return true
    end

    cancelAtaq.onDragMove = function(widget, mousePos, moved)
        if not g_keyboard.isKeyPressed("F2") then -- Changed from F1 to F2
            return false
        end
        local parentRect = widget:getParent():getRect()
        local x = math.min(math.max(parentRect.x, mousePos.x - widget.movingReference.x), parentRect.x + parentRect.width - widget:getWidth())
        local y = math.min(math.max(parentRect.y - widget:getParent():getMarginTop(), mousePos.y - widget.movingReference.y), parentRect.y + parentRect.height - widget:getHeight())
        widget:move(x, y)
        cancelAtaq.moving = { x = cancelAtaq:getX(), y = cancelAtaq:getY() }
        return true
    end

    cancelAtaq.onDragLeave = function(widget, pos)
        storage[nameMacro] = { posX = cancelAtaq:getX(), posY = cancelAtaq:getY() }
    end
end

activeDrag(cancelAtaq, 'stopAttack', storage.stopAttack or {})

--

local limpTxt = macro(500, function() 
    modules.game_textmessage.clearMessages()
    g_map.cleanTexts()
end)
limpTxt = addIcon("NoOrangeTxt", {item = 1982, text = "SPAM"}, limpTxt)

local function activeDrag(icon, nameMacro, position)
    limpTxt:breakAnchors()
    limpTxt:move(position.posX or 330, position.posY or 30)

    limpTxt.onDragEnter = function(widget, mousePos)
        if not g_keyboard.isKeyPressed("F2") then
            return false
        end
        limpTxt:breakAnchors()
        limpTxt.movingReference = { x = mousePos.x - limpTxt:getX(), y = mousePos.y - limpTxt:getY() }
        return true
    end

    limpTxt.onDragMove = function(widget, mousePos, moved)
        if not g_keyboard.isKeyPressed("F2") then
            return false
        end
        local parentRect = widget:getParent():getRect()
        local x = math.min(math.max(parentRect.x, mousePos.x - widget.movingReference.x), parentRect.x + parentRect.width - widget:getWidth())
        local y = math.min(math.max(parentRect.y - widget:getParent():getMarginTop(), mousePos.y - widget.movingReference.y), parentRect.y + parentRect.height - widget:getHeight())
        widget:move(x, y)
        limpTxt.moving = { x = limpTxt:getX(), y = limpTxt:getY() }
        return true
    end

    limpTxt.onDragLeave = function(widget, pos)
        storage[nameMacro] = { posX = limpTxt:getX(), posY = limpTxt:getY() }
    end
end

activeDrag(limpTxt, 'NoOrangeTxt', storage.NoOrangeTxt or {})

--

local target
onAttackingCreatureChange(function(creature, oldCreature)
    if creature then
        target = creature
    end
end)

local lex = addIcon("lex", {item = 20183, text = "EXIVA"}, function()
    if not target then return end
    say('exiva "' .. target:getName())
end)

local function activeDrag(icon, nameMacro, position)
    lex:breakAnchors()
    lex:move(position.posX or 60, position.posY or 350)

    lex.onDragEnter = function(widget, mousePos)
        if not g_keyboard.isKeyPressed("F2") then  -- Changed to F2
            return false
        end
        lex:breakAnchors()
        lex.movingReference = { x = mousePos.x - lex:getX(), y = mousePos.y - lex:getY() }
        return true
    end

    lex.onDragMove = function(widget, mousePos, moved)
        if not g_keyboard.isKeyPressed("F2") then  -- Changed to F2
            return false
        end
        local parentRect = widget:getParent():getRect()
        local x = math.min(math.max(parentRect.x, mousePos.x - widget.movingReference.x), parentRect.x + parentRect.width - widget:getWidth())
        local y = math.min(math.max(parentRect.y - widget:getParent():getMarginTop(), mousePos.y - widget.movingReference.y), parentRect.y + parentRect.height - widget:getHeight())
        widget:move(x, y)
        lex.moving = { x = lex:getX(), y = lex:getY() }
        return true
    end

    lex.onDragLeave = function(widget, pos)
        storage[nameMacro] = { posX = lex:getX(), posY = lex:getY() }
    end
end

activeDrag(lex, 'lex', storage.lex or {})

--

local PvPx = addIcon("onetwo", {item = 37337, text = "PVP"}, function(icon, isOn)
    return g_game.setSafeFight(not isOn)
end)

local function activeDrag(icon, nameMacro, position)
    PvPx:breakAnchors()
    PvPx:move(position.posX or 60, position.posY or 350)

    PvPx.onDragEnter = function(widget, mousePos)
        if not g_keyboard.isKeyPressed("F2") then  -- Changed from F1 to F2
            return false
        end
        PvPx:breakAnchors()
        PvPx.movingReference = { x = mousePos.x - PvPx:getX(), y = mousePos.y - PvPx:getY() }
        return true
    end

    PvPx.onDragMove = function(widget, mousePos, moved)
        if not g_keyboard.isKeyPressed("F2") then  -- Changed from F1 to F2
            return false
        end
        local parentRect = widget:getParent():getRect()
        local x = math.min(math.max(parentRect.x, mousePos.x - widget.movingReference.x), parentRect.x + parentRect.width - widget:getWidth())
        local y = math.min(math.max(parentRect.y - widget:getParent():getMarginTop(), mousePos.y - widget.movingReference.y), parentRect.y + parentRect.height - widget:getHeight())
        widget:move(x, y)
        PvPx.moving = { x = PvPx:getX(), y = PvPx:getY() }
        return true
    end

    PvPx.onDragLeave = function(widget, pos)
        storage[nameMacro] = { posX = PvPx:getX(), posY = PvPx:getY() }  -- Directly save position
    end
end

activeDrag(PvPx, 'onetwo', storage.onetwo or {})


setDefaultTab("Qlq")
-- UI Configuration ENERGY RING
UI.Label("% - Para equipar.")
UI.TextEdit(hp.min, function(widget, text)
    hp.min = tonumber(text) or 80  -- Default 80 si no es número
end)

UI.Label("% Para desequipar.")
UI.TextEdit(hp.max, function(widget, text)
    hp.max = tonumber(text) or 99  -- Default 99 si no es número
end)



tabs:setHeight(math.ceil(#tabs.tabs / 5)* 20)
 for k,tab in ipairs(tabs.tabs) do
    if math.fmod(k, 6) == 0 then
        tab:mergeStyle({ ['$!first'] = { }})
        tab:addAnchor(modules.corelib.AnchorTop, "prev", modules.corelib.AnchorBottom)
        tab:addAnchor(modules.corelib.AnchorLeft, "parent", modules.corelib.AnchorLeft)
    elseif k > 6 then
        tab:mergeStyle({ ['$!first'] = { }})
        tab:addAnchor(modules.corelib.AnchorTop, "prev", modules.corelib.AnchorTop)
        tab:addAnchor(modules.corelib.AnchorLeft, "prev", modules.corelib.AnchorRight)
    end   
 end
